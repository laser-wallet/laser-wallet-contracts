{
  "language": "Solidity",
  "sources": {
    "contracts/core/Me.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title Me - Only address(this) can perform certain operations.\n */\ncontract Me {\n    error Me__notMe();\n\n    modifier onlyMe() {\n        if (msg.sender != address(this)) revert Me__notMe();\n\n        _;\n    }\n}\n"
    },
    "contracts/core/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ISingleton.sol\";\nimport \"./Me.sol\";\n\n/**\n * @title Singleton - Master copy contract. \n */\ncontract Singleton is ISingleton, Me {\n    ///@dev Singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    /// It should also always be ensured that the address is stored alone (uses a full word).\n    address public singleton;\n\n    /**\n     * @dev Migrates to a new singleton (implementation).\n     * @param _singleton New implementation address.\n     */\n    function upgradeSingleton(address _singleton) external onlyMe {\n        if (_singleton == address(this)) revert Singleton__upgradeSingleton__incorrectAddress();\n\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) {\n            //bytes4(keccak256(\"I_AM_LASER\")))\n            revert Singleton__upgradeSingleton__notLaser();\n        } else {\n            assembly {\n                // We store the singleton at storage slot 0 through inline assembly to save some gas and to be very explicit about slot positions.\n                sstore(0, _singleton)\n            }\n            emit SingletonChanged(_singleton);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title IERC165\n * @notice Support of ERC165.\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceID The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     * interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ISingleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title ISingleton\n * @notice Has all the external functions, events and errors for Singleton.sol.\n */\n\ninterface ISingleton {\n    event SingletonChanged(address indexed newSingleton);\n\n    ///@dev upgradeSingleton() custom errors.\n    error Singleton__upgradeSingleton__incorrectAddress();\n    error Singleton__upgradeSingleton__notLaser();\n\n    /**\n     * @dev Migrates to a new singleton (implementation).\n     * @param singleton New implementation address.\n     */\n    function upgradeSingleton(address singleton) external;\n}\n"
    },
    "contracts/LaserWallet.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"./core/Singleton.sol\";\nimport \"./handlers/Handler.sol\";\nimport \"./interfaces/ILaserWallet.sol\";\nimport \"./ssr/SSR.sol\";\n\n/**\n * @title LaserWallet - EVM based smart contract wallet. Implementes smart social recovery mechanism.\n * @author Rodrigo Herrera I.\n */\ncontract LaserWallet is ILaserWallet, Singleton, SSR, Handler {\n    string public constant VERSION = \"1.0.0\";\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n\n    bytes32 private constant LASER_TYPE_STRUCTURE =\n        keccak256(\n            \"LaserOperation(address to,uint256 value,bytes callData,uint256 nonce,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 gasLimit)\"\n        );\n\n    bytes4 private constant EIP1271_MAGIC_VALUE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n\n    uint256 public nonce;\n\n    constructor() {\n        // This makes the singleton unusable. e.g. (parity wallet hack).\n        owner = address(this);\n    }\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Setup function, sets initial storage of contract.\n     * @param _owner The owner of the wallet.\n     * @param _recoveryOwners Array of recovery owners. Implementation of Sovereign Social Recovery.\n     * @param _guardians Addresses that can activate the social recovery mechanism.\n     * @notice It can't be called after initialization.\n     */\n    function init(\n        address _owner,\n        address[] calldata _recoveryOwners,\n        address[] calldata _guardians,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata ownerSignature\n    ) external {\n        // initOwner() requires that the current owner is address 0.\n        // This is enough to protect init() from being called after initialization.\n        initOwner(_owner);\n\n        // We initialize the guardians ...\n        initGuardians(_guardians);\n\n        // We initialize the recovery owners ...\n        initRecoveryOwners(_recoveryOwners);\n\n        {\n            // Scope to avoid stack too deep ...\n\n            bytes32 signedHash = keccak256(abi.encodePacked(maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n\n            (bytes32 r, bytes32 s, uint8 v) = splitSigs(ownerSignature, 0);\n\n            address signer = returnSigner(signedHash, r, s, v, ownerSignature);\n\n            //@todo Optimize this.\n            if (signer != _owner) revert LW__init__notOwner();\n        }\n\n        if (gasLimit > 0) {\n            // If gas limit is greater than 0, then the transaction was sent through a relayer.\n            // We calculate the gas price, as per the user's request ...\n            uint256 gasPrice = calculateGasPrice(maxFeePerGas, maxPriorityFeePerGas);\n\n            // gasUsed is the total amount of gas consumed for this transaction.\n            // This is contemplating the initial callData cost, the main transaction,\n            // and we add the surplus for what is left (refund the relayer).\n            uint256 gasUsed = gasLimit - gasleft() + 7000;\n            uint256 refundAmount = gasUsed * gasPrice;\n\n            // We refund the relayer ...\n            bool success = _call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n\n            // If the transaction returns false, we revert ...\n            if (!success) revert LW__init__refundFailure();\n        }\n\n        emit Setup(_owner, _recoveryOwners, _guardians);\n    }\n\n    /**\n     * @dev Executes a generic transaction. It does not support 'delegatecall' for security reasons.\n     * @param to Destination address.\n     * @param value Amount to send.\n     * @param callData Data payload for the transaction.\n     * @param _nonce Unsigned integer to avoid replay attacks. It needs to match the current wallet's nonce.\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param relayer Address that forwards the transaction so it abstracts away the gas costs.\n     * @param signatures The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata signatures\n    ) external {\n        // We immediately increase the nonce to avoid replay attacks.\n        unchecked {\n            if (nonce++ != _nonce) revert LW__exec__invalidNonce();\n        }\n\n        // Verifies the correctness of the transaction. It checks that the signatures are\n        // correct and that the signer has access for the transaction.\n        verifyTransaction(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, signatures);\n\n        // Once we verified that the transaction is correct, we execute the main call.\n        // We subtract 10_000 to have enough gas to complete the function.\n        bool success = _call(to, value, callData, gasleft() - 10000);\n\n        // We do not revert the call if it fails, because the wallet needs to pay the relayer even in case of failure.\n        if (success) emit ExecSuccess(to, value, nonce);\n        else emit ExecFailure(to, value, nonce);\n\n        // We calculate the gas price, as per the user's request ...\n        uint256 gasPrice = calculateGasPrice(maxFeePerGas, maxPriorityFeePerGas);\n\n        // gasUsed is the total amount of gas consumed for this transaction.\n        // This is contemplating the initial callData cost, the main transaction,\n        // and we add the surplus for what is left (refund the relayer).\n        uint256 gasUsed = gasLimit - gasleft() + 7000;\n\n        uint256 refundAmount = gasUsed * gasPrice;\n\n        // We refund the relayer ...\n        success = _call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n\n        // If the transaction returns false, we revert ..\n        if (!success) revert LW__exec__refundFailure();\n    }\n\n    /**\n     * @dev Executes a series of generic transactions. It can only be called from exec.\n     * @param transactions Basic transactions array (to, value, calldata).\n     */\n    function multiCall(Transaction[] calldata transactions) external onlyMe {\n        uint256 transactionsLength = transactions.length;\n        for (uint256 i = 0; i < transactionsLength; ) {\n            Transaction calldata transaction = transactions[i];\n\n            // We get the actual function selector to determine access ...\n            bytes4 funcSelector = bytes4(transaction.callData);\n\n            // access() checks if the wallet is locked for the owner or guardians and returns who has access ...\n            Access access = access(funcSelector);\n\n            // Only the owner is allowed to trigger a multiCall.\n            // The signatures were already verified in 'exec', here we just need to make sure that access == owner.\n            if (access != Access.Owner) revert LW__multiCall__notOwner();\n\n            bool success = _call(transaction.to, transaction.value, transaction.callData, gasleft());\n\n            // We do not revert the call if it fails, because the wallet needs to pay the relayer even in case of failure.\n            (success);\n\n            //@todo Return the success transactions and return data in an array.\n\n            unchecked {\n                // Won't overflow .... You would need way more gas usage than current available block gas (30m) to overflow it.\n                ++i;\n            }\n        }\n    }\n\n    /**c\n     * @dev Simulates a transaction. This should be called from the relayer, to verify that the transaction will not revert.\n     * This does not guarantees 100% that the transaction will succeed, the state will be different next block.\n     * @notice Needs to be called off-chain from  address zero.\n     */\n    function simulateTransaction(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes calldata signatures\n    ) external returns (uint256 totalGas) {\n        if (nonce++ != _nonce) revert LW__simulateTransaction__invalidNonce();\n        verifyTransaction(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, signatures);\n        bool success = _call(to, value, callData, gasleft());\n        if (!success) revert LW__simulateTransaction__mainCallError();\n        uint256 gasPrice = calculateGasPrice(maxFeePerGas, maxPriorityFeePerGas);\n        uint256 gasUsed = gasLimit - gasleft() + 7000;\n        uint256 refundAmount = gasUsed * gasPrice;\n        success = _call(msg.sender, refundAmount, new bytes(0), gasleft());\n        if (!success) revert LW__simulateTransaction__refundFailure();\n        totalGas = gasLimit - gasleft();\n        require(msg.sender == address(0), \"Must be called off-chain from address zero.\");\n    }\n\n    /**\n     * @dev The transaction's hash. This is necessary to check that the signatures are correct and to avoid replay attacks.\n     */\n    function operationHash(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32) {\n        return keccak256(encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n    }\n\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (r, s, v) = splitSigs(signature, 0);\n        address recovered = returnSigner(hash, r, s, v, signature);\n\n        // The guardians and recovery owners should not be able to sign transactions that are out of scope from this wallet.\n        // Only the owner should be able to sign external data.\n        if (recovered != owner) revert LaserWallet__invalidSignature();\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /**\n     * @return chainId The chain id of this.\n     */\n    function getChainId() public view returns (uint256 chainId) {\n        return block.chainid;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Verifies that the transaction is correct (signatures match the parameters).\n     */\n    function verifyTransaction(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes calldata signatures\n    ) internal view {\n        // We encode the transaction data.\n        bytes memory encodedData = encodeOperation(\n            to,\n            value,\n            callData,\n            _nonce,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit\n        );\n\n        // Now we hash it ...\n        bytes32 dataHash = keccak256(encodedData);\n\n        // We get the actual function selector to determine access ...\n        bytes4 funcSelector = bytes4(callData);\n\n        // access() checks if the wallet is locked for the owner or guardians and returns who has access ...\n        Access access = access(funcSelector);\n\n        // We verify that the signatures are correct depending on the transaction type ...\n        verifySignatures(access, dataHash, signatures);\n    }\n\n    /**\n     * @dev Verifies that the signature(s) match the transaction type and sender.\n     * @param _access Who has permission to invoke this transaction.\n     * @param dataHash The keccak256 has of the transaction's data playload.\n     * @param signatures The signature(s) of the hash.\n     */\n    function verifySignatures(\n        Access _access,\n        bytes32 dataHash,\n        bytes calldata signatures\n    ) internal view {\n        // If it is the owner or guardian, then only 1 signature is required.\n        // For all other operations, 2 signatures are required.\n        uint256 requiredSignatures = _access == Access.Owner || _access == Access.Guardian ? 1 : 2;\n\n        if (signatures.length < requiredSignatures * 65) revert LW__verifySignatures__invalidSignatureLength();\n\n        address signer;\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        for (uint256 i = 0; i < requiredSignatures; ) {\n            (r, s, v) = splitSigs(signatures, i);\n\n            signer = returnSigner(dataHash, r, s, v, signatures);\n\n            if (_access == Access.Owner) {\n                // If access == owner, the signer needs to be the owner.\n\n                // We do not need further checks e.g 'is the wallet locked', they were done in 'access'.\n                if (owner != signer) revert LW__verifySignatures__notOwner();\n            } else if (_access == Access.Guardian) {\n                // If access == guardian, the signer needs to be a guardian.\n\n                // The guardian by itself can only lock the wallet, additional checks were done in 'access'.\n                if (guardians[signer] == address(0)) revert LW__verifySignatures__notGuardian();\n            } else if (_access == Access.OwnerAndGuardian) {\n                // If access == owner and guardian, the first signer needs to be the owner.\n                if (i == 0) {\n                    // The first signer needs to be the owner.\n                    if (owner != signer) revert LW__verifySignatures__notOwner();\n                } else {\n                    // The second signer needs to be a guardian.\n                    if (guardians[signer] == address(0)) revert LW__verifySignatures__notGuardian();\n                }\n            } else if (_access == Access.RecoveryOwnerAndGuardian) {\n                // If access == recovery owner and guardian, the first signer needs to be the recovery owner.\n\n                // We do not need further checks, they were done in 'access'.\n                if (i == 0) {\n                    // The first signer needs to be a recovery owner.\n\n                    // validateRecoveryOwner() handles all the necessary checks.\n                    validateRecoveryOwner(signer);\n                } else {\n                    // The second signer needs to be a guardian.\n                    if (guardians[signer] == address(0)) revert LW__verifySignatures__notGuardian();\n                }\n            } else if (_access == Access.OwnerAndRecoveryOwner) {\n                // If access == owner and recovery owner, the first signer needs to be the owner.\n\n                if (i == 0) {\n                    if (owner != signer) revert LW__verifySignatures__notOwner();\n                } else {\n                    // The second signer needs to be the recovery owner.\n\n                    // validateRecoveryOwner() handles all the necessary checks.\n                    validateRecoveryOwner(signer);\n                }\n            } else {\n                // This else statement should never reach.\n                revert();\n            }\n\n            unchecked {\n                // Won't overflow ...\n                ++i;\n            }\n        }\n    }\n\n    function encodeOperation(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) internal view returns (bytes memory) {\n        bytes32 opHash = keccak256(\n            abi.encode(\n                LASER_TYPE_STRUCTURE,\n                to,\n                value,\n                keccak256(callData),\n                _nonce,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit\n            )\n        );\n\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), opHash);\n    }\n}\n"
    },
    "contracts/handlers/Handler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"../interfaces/IHandler.sol\";\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @title TokenHandler - Supports token callbacks.\n */\ncontract Handler is IHandler, IERC165 {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result) {\n        return 0xbc197c81;\n    }\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure {}\n\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return\n            _interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165\n            _interfaceId == 0x1626ba7e || // EIP 1271\n            _interfaceId == 0xd9b67a26 || // ERC165 interface ID for ERC1155\n            _interfaceId == 0x4e2312e0 || // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n            _interfaceId == 0xae029e0b || // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\"))\n            _interfaceId == 0x150b7a02; // ERC721 onErc721Received\n    }\n}\n"
    },
    "contracts/interfaces/ILaserWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title ILaserWallet\n * @author Rodrigo Herrera I.\n * @notice Has all the external functions, structs, events and errors for LaserWallet.sol.\n */\ninterface ILaserWallet {\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes callData;\n    }\n\n    event Received(address indexed sender, uint256 amount);\n    event Setup(address owner, address[] recoveryOwners, address[] guardians);\n    event ExecSuccess(address to, uint256 value, uint256 nonce);\n    event ExecFailure(address to, uint256 value, uint256 nonce);\n\n    ///@dev init() custom error.\n    error LW__init__notOwner();\n    error LW__init__refundFailure();\n\n    ///@dev exec() custom errors.\n    error LW__exec__invalidNonce();\n    error LW__exec__refundFailure();\n\n    ///@dev multiCall() custom error.\n    error LW__multiCall__notOwner();\n\n    ///@dev simulateTransaction() custom errors.\n    error LW__simulateTransaction__invalidNonce();\n    error LW__simulateTransaction__mainCallError();\n    error LW__simulateTransaction__refundFailure();\n\n    ///@dev isValidSignature() Laser custom error.\n    error LaserWallet__invalidSignature();\n\n    ///@dev verifySignatures() custom errors.\n    error LW__verifySignatures__invalidSignatureLength();\n    error LW__verifySignatures__notOwner();\n    error LW__verifySignatures__notGuardian();\n\n    /**\n     * @dev Setup function, sets initial storage of contract.\n     * @param _owner The owner of the wallet.\n     * @param _recoveryOwners Array of recovery owners. Implementation of Sovereign Social Recovery.\n     * @param _guardians Addresses that can activate the social recovery mechanism.\n     * @notice It can't be called after initialization.\n     */\n    function init(\n        address _owner,\n        address[] calldata _recoveryOwners,\n        address[] calldata _guardians,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata ownerSignature\n    ) external;\n\n    /**\n     * @dev Executes a generic transaction. It does not support 'delegatecall' for security reasons.\n     * @param to Destination address.\n     * @param value Amount to send.\n     * @param callData Data payload for the transaction.\n     * @param _nonce Unsigned integer to avoid replay attacks. It needs to match the current wallet's nonce.\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param signatures The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata signatures\n    ) external;\n\n    /**\n     * @dev Executes a series of generic transactions. It can only be called from exec.\n     * @param transactions Basic transactions array (to, value, calldata).\n     */\n    function multiCall(Transaction[] calldata transactions) external;\n\n    /**\n     * @dev Simulates a transaction. This should be called from the relayer, to verify that the transaction will not revert.\n     * This does not guarantees 100% that the transaction will succeed, the state will be different next block.\n     * @notice Needs to be called off-chain from  address zero.\n     */\n    function simulateTransaction(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes calldata signatures\n    ) external returns (uint256 totalGas);\n\n    /**\n     * @dev The transaction's hash. This is necessary to check that the signatures are correct and to avoid replay attacks.\n     */\n    function operationHash(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32);\n\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external returns (bytes4);\n\n    /**\n     * @dev Returns the chain id of this.\n     */\n    function getChainId() external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator of this.\n     * @notice This is done to avoid replay attacks.\n     */\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/ssr/SSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../core/Owner.sol\";\nimport \"../interfaces/IEIP1271.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ISSR.sol\";\nimport \"../utils/Utils.sol\";\n\n/**\n * @title SSR - Smart Social Recovery\n * @notice Laser's recovery mechanism.\n * @author Rodrigo Herrera I.\n */\ncontract SSR is ISSR, Owner, Utils {\n    ///@dev pointer address for the nested mapping.\n    address internal constant pointer = address(0x1);\n\n    uint256 internal recoveryOwnerCount;\n\n    uint256 internal guardianCount;\n\n    uint256 public timeLock;\n\n    bool public isLocked;\n\n    ///@dev If guardians are locked, they cannot do any transaction.\n    ///This is to completely prevent from guardians misbehaving.\n    bool public guardiansLocked;\n\n    // Recovery owners in a link list.\n    mapping(address => address) internal recoveryOwners;\n\n    // Guardians in a link list.\n    mapping(address => address) internal guardians;\n\n    /**\n     * @dev Locks the wallet. Can only be called by a guardian.\n     */\n    function lock() external onlyMe {\n        timeLock = block.timestamp;\n        isLocked = true;\n        emit WalletLocked();\n    }\n\n    /**\n     * @dev Unlocks the wallet. Can only be called by a guardian + the owner.\n     */\n    function unlock() external onlyMe {\n        timeLock = 0;\n        isLocked = false;\n        emit WalletUnlocked();\n    }\n\n    /**\n     * @dev Unlocks the wallet. Can only be called by the owner + a recovery owner.\n     * This is to avoid the wallet being locked forever if a guardian misbehaves.\n     * The guardians will be locked until the owner decides otherwise.\n     */\n    function recoveryUnlock() external onlyMe {\n        isLocked = false;\n        guardiansLocked = true;\n        emit RecoveryUnlocked();\n    }\n\n    /**\n     * @dev Unlocks the guardians. Can only be called by the owner.\n     */\n    function unlockGuardians() external onlyMe {\n        guardiansLocked = false;\n    }\n\n    /**\n     * @dev Can only recover with the signature of a recovery owner and guardian.\n     * @param newOwner The new owner address. This is generated instantaneously.\n     */\n    function recover(address newOwner) external onlyMe {\n        timeLock = 0;\n        isLocked = false;\n        owner = newOwner;\n        emit WalletRecovered(newOwner);\n    }\n\n    /**\n     * @dev Adds a guardian to the wallet.\n     * @param newGuardian Address of the new guardian.\n     * @notice Can only be called by the owner.\n     */\n    function addGuardian(address newGuardian) external onlyMe {\n        verifyNewRecoveryOwnerOrGuardian(newGuardian);\n        guardians[newGuardian] = guardians[pointer];\n        guardians[pointer] = newGuardian;\n\n        unchecked {\n            // If this overflows, this bug would be the least of the problems ..\n            ++guardianCount;\n        }\n        emit NewGuardian(newGuardian);\n    }\n\n    /**\n     * @dev Removes a guardian from the wallet.\n     * @param prevGuardian Address of the previous guardian in the linked list.\n     * @param guardianToRemove Address of the guardian to be removed.\n     * @notice Can only be called by the owner.\n     */\n    function removeGuardian(address prevGuardian, address guardianToRemove) external onlyMe {\n        // There needs to be at least 2 guardian ...\n        if (guardianCount - 2 < 1) revert SSR__removeGuardian__underflow();\n\n        if (guardianToRemove == pointer) revert SSR__removeGuardian__invalidAddress();\n\n        if (guardians[prevGuardian] != guardianToRemove) revert SSR__removeGuardian__incorrectPreviousGuardian();\n\n        guardians[prevGuardian] = guardians[guardianToRemove];\n        guardians[guardianToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 guardians to reach here.\n            --guardianCount;\n        }\n        emit GuardianRemoved(guardianToRemove);\n    }\n\n    /**\n     * @dev Swaps a guardian for a new address.\n     * @param prevGuardian The address of the previous guardian in the link list.\n     * @param newGuardian The address of the new guardian.\n     * @param oldGuardian The address of the current guardian to be swapped by the new one.\n     */\n    function swapGuardian(\n        address prevGuardian,\n        address newGuardian,\n        address oldGuardian\n    ) external onlyMe {\n        verifyNewRecoveryOwnerOrGuardian(newGuardian);\n        if (guardians[prevGuardian] != oldGuardian) revert SSR__swapGuardian__invalidPrevGuardian();\n\n        if (oldGuardian == pointer) revert SSR__swapGuardian__invalidOldGuardian();\n\n        guardians[newGuardian] = guardians[oldGuardian];\n        guardians[prevGuardian] = newGuardian;\n        guardians[oldGuardian] = address(0);\n        emit GuardianSwapped(newGuardian, oldGuardian);\n    }\n\n    /**\n     * @dev Adds a recovery owner to the wallet.\n     * @param newRecoveryOwner Address of the new recovery owner.\n     * @notice Can only be called by the owner.\n     */\n    function addRecoveryOwner(address newRecoveryOwner) external onlyMe {\n        verifyNewRecoveryOwnerOrGuardian(newRecoveryOwner);\n        recoveryOwners[newRecoveryOwner] = recoveryOwners[pointer];\n        recoveryOwners[pointer] = newRecoveryOwner;\n\n        unchecked {\n            // If this overflows, this bug would be the least of the problems ...\n            ++recoveryOwnerCount;\n        }\n        emit NewRecoveryOwner(newRecoveryOwner);\n    }\n\n    /**\n     * @dev Removes a recovery owner  to the wallet.\n     * @param prevRecoveryOwner Address of the previous recovery owner in the linked list.\n     * @param recoveryOwnerToRemove Address of the recovery owner to be removed.\n     * @notice Can only be called by the owner.\n     */\n    function removeRecoveryOwner(address prevRecoveryOwner, address recoveryOwnerToRemove) external onlyMe {\n        // There needs to be at least 2 recovery owners ...\n        if (recoveryOwnerCount - 1 < 2) revert SSR__removeRecoveryOwner__underflow();\n\n        if (recoveryOwnerToRemove == pointer) revert SSR__removeRecoveryOwner__invalidAddress();\n\n        if (recoveryOwners[prevRecoveryOwner] != recoveryOwnerToRemove) {\n            revert SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n        }\n\n        recoveryOwners[prevRecoveryOwner] = recoveryOwners[recoveryOwnerToRemove];\n        recoveryOwners[recoveryOwnerToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 recovery owners to reach here.\n            --recoveryOwnerCount;\n        }\n        emit RecoveryOwnerRemoved(recoveryOwnerToRemove);\n    }\n\n    /**\n     * @dev Swaps a recovery owner for a new address.\n     * @param prevRecoveryOwner The address of the previous owner in the link list.\n     * @param newRecoveryOwner The address of the new recovery owner.\n     * @param oldRecoveryOwner The address of the current recovery owner to be swapped by the new one.\n     */\n    function swapRecoveryOwner(\n        address prevRecoveryOwner,\n        address newRecoveryOwner,\n        address oldRecoveryOwner\n    ) external onlyMe {\n        verifyNewRecoveryOwnerOrGuardian(newRecoveryOwner);\n        if (recoveryOwners[prevRecoveryOwner] != oldRecoveryOwner) {\n            revert SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n        }\n\n        if (oldRecoveryOwner == pointer) {\n            revert SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n        }\n\n        recoveryOwners[newRecoveryOwner] = recoveryOwners[oldRecoveryOwner];\n        recoveryOwners[prevRecoveryOwner] = newRecoveryOwner;\n        recoveryOwners[oldRecoveryOwner] = address(0);\n        emit RecoveryOwnerSwapped(newRecoveryOwner, oldRecoveryOwner);\n    }\n\n    /**\n     * @param guardian Requested address.\n     * @return Boolean if the address is a guardian of the current wallet.\n     */\n    function isGuardian(address guardian) external view returns (bool) {\n        return guardian != pointer && guardians[guardian] != address(0);\n    }\n\n    /**\n     * @param recoveryOwner Requested address.\n     * @return Boolean if the address is a recovery owner of the current wallet.\n     */\n    function isRecoveryOwner(address recoveryOwner) external view returns (bool) {\n        return recoveryOwner != pointer && recoveryOwners[recoveryOwner] != address(0);\n    }\n\n    /**\n     * @return Array of the guardians of this wallet.\n     */\n    function getGuardians() external view returns (address[] memory) {\n        address[] memory guardiansArray = new address[](guardianCount);\n        address currentGuardian = guardians[pointer];\n\n        uint256 index = 0;\n        while (currentGuardian != pointer) {\n            guardiansArray[index] = currentGuardian;\n            currentGuardian = guardians[currentGuardian];\n            unchecked {\n                //Even if it is a view function, we reduce gas costs if it is called by another contract.\n                ++index;\n            }\n        }\n        return guardiansArray;\n    }\n\n    /**\n     * @return Array of the recovery owners of this wallet.\n     */\n    function getRecoveryOwners() external view returns (address[] memory) {\n        address[] memory recoveryOwnersArray = new address[](recoveryOwnerCount);\n        address currentRecoveryOwner = recoveryOwners[pointer];\n\n        uint256 index;\n        while (currentRecoveryOwner != pointer) {\n            recoveryOwnersArray[index] = currentRecoveryOwner;\n            currentRecoveryOwner = recoveryOwners[currentRecoveryOwner];\n            unchecked {\n                // Even if it is a view function, we reduce gas costs if it is called by another contract.\n                ++index;\n            }\n        }\n        return recoveryOwnersArray;\n    }\n\n    /**\n     * @dev Sets up the initial guardian configuration. Can only be called from the init function.\n     * @param _guardians Array of guardians.\n     */\n    function initGuardians(address[] calldata _guardians) internal {\n        uint256 guardiansLength = _guardians.length;\n        // There needs to be at least 2 guardians.\n        if (guardiansLength < 2) revert SSR__initGuardians__underflow();\n\n        address currentGuardian = pointer;\n\n        for (uint256 i = 0; i < guardiansLength; ) {\n            address guardian = _guardians[i];\n            unchecked {\n                // If this overflows, this bug would be the least of the problems ...\n                ++i;\n            }\n            guardians[currentGuardian] = guardian;\n            currentGuardian = guardian;\n            verifyNewRecoveryOwnerOrGuardian(guardian);\n        }\n\n        guardians[currentGuardian] = pointer;\n        guardianCount = guardiansLength;\n    }\n\n    /**\n     * @dev Inits the recovery owners.\n     * @param _recoveryOwners Array of ricovery owners.\n     * @notice There needs to be at least 2 recovery owners.\n     */\n    function initRecoveryOwners(address[] calldata _recoveryOwners) internal {\n        uint256 recoveryOwnersLength = _recoveryOwners.length;\n        // There needs to be at least 2 recovery owners.\n        if (recoveryOwnersLength < 2) revert SSR__initRecoveryOwners__underflow();\n\n        address currentRecoveryOwner = pointer;\n        for (uint256 i = 0; i < recoveryOwnersLength; ) {\n            address recoveryOwner = _recoveryOwners[i];\n            recoveryOwners[currentRecoveryOwner] = recoveryOwner;\n            currentRecoveryOwner = recoveryOwner;\n            verifyNewRecoveryOwnerOrGuardian(recoveryOwner);\n\n            unchecked {\n                // If this overflows, this bug would be the least of the problems ...\n                ++i;\n            }\n        }\n\n        recoveryOwners[currentRecoveryOwner] = pointer;\n        recoveryOwnerCount = recoveryOwnersLength;\n    }\n\n    /**\n     * @dev Returns who has access to call a specific function.\n     * @param funcSelector The function selector: bytes4(keccak256(...)).\n     */\n    function access(bytes4 funcSelector) internal view returns (Access) {\n        if (funcSelector == this.lock.selector) {\n            // Only a guardian can lock the wallet ...\n\n            // If  guardians are locked, we revert ...\n            if (guardiansLocked) revert SSR__access__guardiansLocked();\n            else return Access.Guardian;\n        } else if (funcSelector == this.unlock.selector) {\n            // Only a guardian + the owner can unlock the wallet ...\n\n            return Access.OwnerAndGuardian;\n        } else if (funcSelector == this.recoveryUnlock.selector) {\n            // This is in case a guardian is misbehaving ...\n\n            //Only the owner + a recovery owner can trigger this ...\n            return Access.OwnerAndRecoveryOwner;\n        } else if (funcSelector == this.recover.selector) {\n            // Only the recovery owner + the guardian can recover the wallet (change the owner keys) ...\n\n            return Access.RecoveryOwnerAndGuardian;\n        } else {\n            // Else is the owner ... If the the wallet is locked, we revert ...\n\n            if (isLocked) revert SSR__access__walletLocked();\n            else return Access.Owner;\n        }\n    }\n\n    /**\n     * @dev Validates that a recovery owner can execute an operation 'now'.\n     * @param signer The returned address from the provided signature and hash.\n     */\n    function validateRecoveryOwner(address signer) internal view {\n        // Time elapsed since the recovery mechanism was activated.\n        uint256 elapsedTime = block.timestamp - timeLock;\n        address currentRecoveryOwner = recoveryOwners[pointer];\n        bool authorized;\n        uint256 index;\n\n        while (currentRecoveryOwner != pointer) {\n            if (elapsedTime > 1 weeks * index) {\n                // Each recovery owner (index ordered) has access to sign the transaction after 1 week.\n                // e.g. The first recovery owner (indexed 0) can sign immediately, the second recovery owner needs to wait 1 week, the third 2 weeks, and so on ...\n\n                if (currentRecoveryOwner == signer) authorized = true;\n            }\n            currentRecoveryOwner = recoveryOwners[currentRecoveryOwner];\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        if (!authorized) revert SSR__validateRecoveryOwner__notAuthorized();\n    }\n\n    /**\n     * @dev Checks that the provided address is correct for a new recovery owner or guardian.\n     * @param toVerify The address to verify.\n     */\n    function verifyNewRecoveryOwnerOrGuardian(address toVerify) internal view {\n        if (toVerify.code.length > 0) {\n            // If the recovery owner is a smart contract wallet, it needs to support EIP1271.\n            if (!IERC165(toVerify).supportsInterface(0x1626ba7e)) {\n                revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n            }\n        }\n\n        if (\n            toVerify == address(0) ||\n            toVerify == owner ||\n            guardians[toVerify] != address(0) ||\n            recoveryOwners[toVerify] != address(0)\n        ) revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n    }\n}\n"
    },
    "contracts/interfaces/IHandler.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IHandler\n * @notice Has all the external functions for Handler.sol.\n */\ninterface IHandler {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4);\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure;\n}\n"
    },
    "contracts/core/Owner.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IOwner.sol\";\nimport \"./Me.sol\";\n\n/**\n * @title Owner\n * @notice Handles the owners addresses.\n */\ncontract Owner is IOwner, Me {\n    ///@dev owner should always bet at storage slot 1.\n    address public owner;\n\n    /**\n     * @dev Changes the owner of the wallet.\n     * @param newOwner The address of the new owner.\n     */\n    function changeOwner(address newOwner) external onlyMe {\n        if (newOwner.code.length != 0 || newOwner == address(0) || newOwner == owner) {\n            revert Owner__changeOwner__invalidOwnerAddress();\n        }\n        assembly {\n            // We store the owner at storage slot 1 through inline assembly to save some gas and to be very explicit about slot positions.\n            sstore(1, newOwner)\n        }\n        emit OwnerChanged(newOwner);\n    }\n\n    /**\n     * @dev Inits the owner. This can only be called at creation.\n     * @param _owner The owner of the wallet.\n     */\n    function initOwner(address _owner) internal {\n        // If owner is not address 0, the wallet was already initialized ...\n        if (owner != address(0)) revert Owner__initOwner__walletInitialized();\n\n        if (_owner.code.length != 0 || _owner == address(0)) revert Owner__initOwner__invalidOwnerAddress();\n\n        assembly {\n            // We store the owner at storage slot 1 through inline assembly to save some gas and to be very explicit about slot positions.\n            sstore(1, _owner)\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IEIP1271.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IEIP1271\n * @notice Interface to call external contracts to validate signature.\n */\ninterface IEIP1271 {\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ISSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title ISSR\n * @notice Has all the external functions, structs, events and errors for SSR.sol.\n */\ninterface ISSR {\n    ///@dev Determines who has access to call a specific function.\n    enum Access {\n        Owner,\n        Guardian,\n        OwnerAndGuardian,\n        RecoveryOwnerAndGuardian,\n        OwnerAndRecoveryOwner\n    }\n\n    event WalletLocked();\n    event WalletUnlocked();\n    event RecoveryUnlocked();\n    event NewGuardian(address newGuardian);\n    event GuardianRemoved(address removedGuardian);\n    event GuardianSwapped(address newGuardian, address oldGuardian);\n    event NewRecoveryOwner(address newRecoveryOwner);\n    event RecoveryOwnerRemoved(address removedRecoveryOwner);\n    event RecoveryOwnerSwapped(address newRecoveryOwner, address oldRecoveryOwner);\n    event WalletRecovered(address newOwner);\n\n    ///@dev addGuardian() custom errors.\n    error SSR__addGuardian__invalidAddress();\n\n    ///@dev removeGuardian() custom errors.\n    error SSR__removeGuardian__underflow();\n    error SSR__removeGuardian__invalidAddress();\n    error SSR__removeGuardian__incorrectPreviousGuardian();\n\n    ///@dev swapRecoveryOwner() custom errors.\n    error SSR__swapGuardian__invalidPrevGuardian();\n    error SSR__swapGuardian__invalidOldGuardian();\n\n    ///@dev addRecoveryOwner() custom error.\n    error SSR__addRecoveryOwner__invalidAddress();\n\n    ///@dev removeRecoveryOwner() custom errors.\n    error SSR__removeRecoveryOwner__underflow();\n    error SSR__removeRecoveryOwner__invalidAddress();\n    error SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n\n    ///@dev swapRecoveryOwner() custom errors.\n    error SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n    error SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n\n    ///@dev initRecoveryOwners() custom error.\n    error SSR__initRecoveryOwners__underflow();\n    error SSR__initRecoveryOwners__invalidAddress();\n\n    ///@dev initGuardians() custom errors.\n    error SSR__initGuardians__underflow();\n    error SSR__initGuardians__invalidAddress();\n\n    ///@dev access() custom errors.\n    error SSR__access__guardiansLocked();\n    error SSR__access__walletLocked();\n\n    ///@dev validateRecoveryOwner() custom error.\n    error SSR__validateRecoveryOwner__notAuthorized();\n\n    ///@dev verifyNewRecoveryOwnerOrGuardian() custom error.\n    error SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n\n    /**\n     * @dev Locks the wallet. Can only be called by a guardian.\n     */\n    function lock() external;\n\n    /**\n     * @dev Unlocks the wallet. Can only be called by a guardian + the owner.\n     */\n    function unlock() external;\n\n    /**\n     * @dev Unlocks the wallet. Can only be called by the owner + a recovery owner.\n     * This is to avoid the wallet being locked forever if a guardian misbehaves.\n     * The guardians will be locked until the owner decides otherwise.\n     */\n    function recoveryUnlock() external;\n\n    /**\n     * @dev Unlocks the guardians. Can only be called by the owner.\n     */\n    function unlockGuardians() external;\n\n    /**\n     * @dev Can only recover with the signature of a recovery owner and guardian.\n     * @param newOwner The new owner address. This is generated instantaneously.\n     */\n    function recover(address newOwner) external;\n\n    /**\n     * @dev Adds a guardian to the wallet.\n     * @param newGuardian Address of the new guardian.\n     * @notice Can only be called by the owner.\n     */\n    function addGuardian(address newGuardian) external;\n\n    /**\n     * @dev Removes a guardian to the wallet.\n     * @param prevGuardian Address of the previous guardian in the linked list.\n     * @param guardianToRemove Address of the guardian to be removed.\n     * @notice Can only be called by the owner.\n     */\n    function removeGuardian(address prevGuardian, address guardianToRemove) external;\n\n    /**\n     * @dev Swaps a guardian for a new address.\n     * @param prevGuardian The address of the previous guardian in the link list.\n     * @param newGuardian The address of the new guardian.\n     * @param oldGuardian The address of the current guardian to be swapped by the new one.\n     */\n    function swapGuardian(\n        address prevGuardian,\n        address newGuardian,\n        address oldGuardian\n    ) external;\n\n    /**\n     * @dev Adds a recovery owner to the wallet.\n     * @param newRecoveryOwner Address of the new recovery owner.\n     * @notice Can only be called by the owner.\n     */\n    function addRecoveryOwner(address newRecoveryOwner) external;\n\n    /**\n     * @dev Removes a recovery owner  to the wallet.\n     * @param prevRecoveryOwner Address of the previous recovery owner in the linked list.\n     * @param recoveryOwnerToRemove Address of the recovery owner to be removed.\n     * @notice Can only be called by the owner.\n     */\n    function removeRecoveryOwner(address prevRecoveryOwner, address recoveryOwnerToRemove) external;\n\n    /**\n     * @dev Swaps a recovery owner for a new address.\n     * @param prevRecoveryOwner The address of the previous owner in the link list.\n     * @param newRecoveryOwner The address of the new recovery owner.\n     * @param oldRecoveryOwner The address of the current recovery owner to be swapped by the new one.\n     */\n    function swapRecoveryOwner(\n        address prevRecoveryOwner,\n        address newRecoveryOwner,\n        address oldRecoveryOwner\n    ) external;\n\n    /**\n     * @param guardian Requested address.\n     * @return Boolean if the address is a guardian of the current wallet.\n     */\n    function isGuardian(address guardian) external view returns (bool);\n\n    /**\n     * @param recoveryOwner Requested address.\n     * @return Boolean if the address is a recovery owner of the current wallet.\n     */\n    function isRecoveryOwner(address recoveryOwner) external view returns (bool);\n\n    /**\n     * @return Array of the guardians of this wallet.\n     */\n    function getGuardians() external view returns (address[] memory);\n\n    /**\n     * @return Array of the recovery owners of this wallet.\n     */\n    function getRecoveryOwners() external view returns (address[] memory);\n}\n"
    },
    "contracts/utils/Utils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IUtils.sol\";\nimport \"../interfaces/IEIP1271.sol\";\n\n/**\n * @title Utils - Helper functions for Laser wallet.\n */\ncontract Utils is IUtils {\n    /**\n     * @dev Returns the signer of the hash.\n     * @param dataHash The hash that was signed.\n     */\n    function returnSigner(\n        bytes32 dataHash,\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory signatures\n    ) public view returns (address signer) {\n        if (v == 0) {\n            // If v is 0, then it is a contract signature.\n            // The address of the contract is encoded into r.\n            signer = address(uint160(uint256(r)));\n\n            // // The actual signature.\n            bytes memory contractSignature;\n\n            assembly {\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n\n            if (IEIP1271(signer).isValidSignature(dataHash, contractSignature) != 0x1626ba7e) {\n                revert Utils__returnSigner__invalidContractSignature();\n            }\n        } else if (v > 30) {\n            signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n        } else {\n            signer = ecrecover(dataHash, v, r, s);\n        }\n\n        if (signer == address(0)) revert Utils__returnSigner__invalidSignature();\n    }\n\n    /**\n     * @dev Returns the r, s and v of the signature.\n     * @param signatures Signature.\n     * @param pos Which signature to read.\n     */\n    function splitSigs(bytes memory signatures, uint256 pos)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        assembly {\n            let sigPos := mul(0x41, pos)\n            r := mload(add(signatures, add(sigPos, 0x20)))\n            s := mload(add(signatures, add(sigPos, 0x40)))\n            v := byte(0, mload(add(signatures, add(sigPos, 0x60))))\n        }\n    }\n\n    /**\n     * @dev Calls a target address, sends value and / or data payload.\n     * @param to Destination address.\n     * @param value Amount to send in ETH.\n     * @param data Data payload.\n     * @param txGas Amount of gas to forward.\n     */\n    function _call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            // We execute a call to the target address and return boolean...\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /**\n     * @dev Calculates the gas price.\n     */\n    function calculateGasPrice(uint256 maxFeePerGas, uint256 maxPriorityFeePerGas)\n        internal\n        view\n        returns (uint256 gasPrice)\n    {\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            // Legacy mode.\n            gasPrice = maxFeePerGas;\n        } else {\n            gasPrice = min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/interfaces/IOwner.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IOwner\n * @notice Has all the external functions, events and errors for Owner.sol.\n */\ninterface IOwner {\n    event OwnerChanged(address newOwner);\n\n    ///@dev changeOwner() custom error.\n    error Owner__changeOwner__invalidOwnerAddress();\n\n    ///@dev initOwner() custom errors.\n    error Owner__initOwner__walletInitialized();\n    error Owner__initOwner__invalidOwnerAddress();\n\n    /**\n     * @dev Changes the owner of the wallet.\n     * @param newOwner The address of the new owner.\n     */\n    function changeOwner(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/IUtils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IUtils\n * @notice Has all the external functions and errors for Utils.sol.\n */\ninterface IUtils {\n    ///@dev returnSigner() custom error.\n    error Utils__returnSigner__invalidSignature();\n    error Utils__returnSigner__invalidContractSignature();\n\n    /**\n     * @dev Returns the signer of the hash.\n     * @param dataHash The hash that was signed.\n     */\n    function returnSigner(\n        bytes32 dataHash,\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory signatures\n    ) external view returns (address signer);\n\n    /**\n     * @dev Returns the r, s and v of the signature.\n     * @param signatures Signature.\n     * @param pos Which signature to read.\n     */\n    function splitSigs(bytes memory signatures, uint256 pos)\n        external\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        );\n}\n"
    },
    "contracts/test/TestMigrate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../LaserWallet.sol\";\n\ncontract TestMigrate is LaserWallet {\n    function imNew() external pure returns (string memory) {\n        return \"New\";\n    }\n}\n"
    },
    "contracts/proxies/LaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ILaserFactory.sol\";\n\ninterface ILaser {\n    function init(\n        address _owner,\n        address[] calldata _recoveryOwners,\n        address[] calldata _guardians,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata signature\n    ) external;\n}\n\n/**\n * @title LaserFactory - Factory for creating new Laser proxies and helper methods.\n */\ncontract LaserFactory is ILaserFactory {\n    address public immutable singleton;\n\n    /**\n     * @param _singleton Master copy of the proxy.\n     */\n    constructor(address _singleton) {\n        // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\"))\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) revert LaserFactory__constructor__invalidSingleton();\n        singleton = _singleton;\n    }\n\n    /**\n     * @dev Creates a new proxy with create 2, initializes the wallet and refunds the relayer (if gas limit is greater than 0).\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param relayer Address that forwards the transaction so it abstracts away the gas costs.\n     * @param ownerSignature The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function deployProxyAndRefund(\n        address owner,\n        address[] calldata recoveryOwners,\n        address[] calldata guardians,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        uint256 saltNumber,\n        bytes calldata ownerSignature\n    ) external returns (LaserProxy proxy) {\n        bytes32 salt = getSalt(owner, recoveryOwners, guardians, saltNumber);\n        proxy = createProxyWithCreate2(salt);\n\n        ILaser(address(proxy)).init(\n            owner,\n            recoveryOwners,\n            guardians,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit,\n            relayer,\n            ownerSignature\n        );\n\n        emit ProxyCreation(address(proxy));\n    }\n\n    /**\n     * @dev Precomputes the address of a proxy that is created through 'create2'.\n     */\n    function preComputeAddress(\n        address owner,\n        address[] calldata recoveryOwners,\n        address[] calldata guardians,\n        uint256 saltNumber\n    ) external view returns (address) {\n        bytes memory creationCode = proxyCreationCode();\n        bytes memory data = abi.encodePacked(creationCode, uint256(uint160(singleton)));\n\n        bytes32 salt = getSalt(owner, recoveryOwners, guardians, saltNumber);\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(data)));\n\n        return address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n     */\n    function proxyRuntimeCode() external pure returns (bytes memory) {\n        return type(LaserProxy).runtimeCode;\n    }\n\n    /**\n     *  @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n     */\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(LaserProxy).creationCode;\n    }\n\n    /**\n     * @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n     * This method is only meant as an utility to be called from other methods.\n     */\n    function createProxyWithCreate2(bytes32 salt) internal returns (LaserProxy proxy) {\n        bytes memory deploymentData = abi.encodePacked(type(LaserProxy).creationCode, uint256(uint160(singleton)));\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        //@todo change the custom error name.\n        if (address(proxy) == address(0)) revert LaserFactory__deployProxyWithNonce__create2Failed();\n    }\n\n    /**\n     * @dev Generates the salt for deployment.\n     */\n    function getSalt(\n        address owner,\n        address[] calldata recoveryOwners,\n        address[] calldata guardians,\n        uint256 saltNumber\n    ) internal pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(owner, recoveryOwners, guardians, saltNumber));\n    }\n}\n"
    },
    "contracts/interfaces/ILaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../proxies/LaserProxy.sol\";\n\n/**\n * @title ILaserFactory.\n * @notice Has all the external functions, events and errors for ProxyFactory.sol.\n */\n\ninterface ILaserFactory {\n    event ProxyCreation(address proxy);\n\n    ///@dev constructor() custom error.\n    error LaserFactory__constructor__invalidSingleton();\n\n    ///@dev createProxyWithCreate2() custom error.\n    error LaserFactory__deployProxyWithNonce__create2Failed();\n\n    /**\n     * @dev Creates a new proxy with create 2, initializes the wallet and refunds the relayer.\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param relayer Address that forwards the transaction so it abstracts away the gas costs.\n     * @param ownerSignature The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function deployProxyAndRefund(\n        address owner,\n        address[] calldata recoveryOwners,\n        address[] calldata guardians,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        uint256 saltNumber,\n        bytes calldata ownerSignature\n    ) external returns (LaserProxy proxy);\n\n    /**\n     * @dev Precomputes the address of a proxy that is created through 'create2'.\n     */\n    function preComputeAddress(\n        address owner,\n        address[] calldata recoveryOwners,\n        address[] calldata guardians,\n        uint256 saltNumber\n    ) external view returns (address);\n\n    /**\n     * @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n     */\n    function proxyRuntimeCode() external pure returns (bytes memory);\n\n    /**\n     *  @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n     */\n    function proxyCreationCode() external pure returns (bytes memory);\n}\n"
    },
    "contracts/proxies/LaserProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title LaserProxy - Proxy contract that delegates all calls to a master copy.\n */\ncontract LaserProxy {\n    // The singleton always needs to be at storage slot 0.\n    address internal singleton;\n\n    /**\n     * @param _singleton Singleton address.\n     */\n    constructor(address _singleton) {\n        // The proxy creation is done through the LaserProxyFactory.\n        // The singleton is created at the factory's creation, so there is no need to do checks here.\n        singleton = _singleton;\n    }\n\n    /**\n     * @dev Fallback function forwards all transactions and returns all received return data.\n     */\n    fallback() external payable {\n        address _singleton = singleton;\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}